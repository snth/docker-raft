#!/bin/bash
set -e

# Print metadata for Docker CLI plugin
if [[ "$1" == "docker-cli-plugin-metadata" ]]; then
  cat <<EOF
{
  "SchemaVersion": "0.1.0",
  "Vendor": "Tobias Brandt",
  "Version": "v0.1",
  "ShortDescription": "Emulate docker-compose CLI for Docker Swarm"
}
EOF
  exit
fi

# Shift arguments to remove plugin name
[ "$1" = "raft" ] && shift

# TODO: correctly display name depending on whether called as a Docker CLI
#		plugin or script.
#DOCKERCMD=$(echo "$0" | sed 's/.*\///' | sed 's/[^-]*-//')
DOCKERCMD=$(echo "$(basename $0)" | sed 's/.*\///' | sed 's/-/ /')

# Utility command because Docker Compose quotes the published port numbers
# whereas Docker Stack expects these to be numbers.
UNQUOTE_NUMBERS_CMD=( 'sed' '-r' 's/: ["]*([0-9]+)["]*/: \1/g' )

# Defaults
DEFAULT_PORT=2375
DEFAULT_ENV_FILES=( '--env-file' '.env' )
DEFAULT_CONFIG_FILES=( 'docker-compose.yml' )
DEFAULT_EXEC_ARGS=bash
DEFAULT_LOGS_ARGS=

# Functions
function invalid() {
  echo "ERROR: Unrecognized argument: ${1}" >&2
  usage_command
  exit 1
}

function missing() {
    echo "ERROR: ${1} must be specified" >&2
    usage_command
    exit 1
}

function prefix_array() {
    IFS=$'\ca' local prefix="${1-}" input=( ${2-} )
    #local prefix="${1-}" input=( ${2[@]-} )
    # in order to modify the input array we have to use eval
    #eval $2="()"
    for elem in "${input[@]}"; do
        echo "$prefix"
        echo "$elem"
    #    #eval $2+="($prefix $elem)"
    done
}

function preprocess() {
	# Pre-process options to:
	# - expand -xyz into -x -y -z
	# - expand --longopt=arg into --longopt arg
	ARGV=()
	while [[ $# -gt 0 ]]; do
		arg="$1"; shift
		case "${END_OF_OPT}${arg}" in
			--) 	ARGV+=("$arg"); ;;
			--*=*)	ARGV+=("${arg%%=*}" "${arg#*=}") ;;
			--*) 	ARGV+=("$arg") ;;
			-*) 	for i in $(seq 2 ${#arg}); do 
						ARGV+=("-${arg:i-1:1}"); 
					done ;;
			*) 		ARGV+=("$arg") ;;
		esac
	done
}

# Report usage
function usage_command() {
	cat <<EOF

Usage: $DOCKERCMD [OPTIONS] COMMAND [ARG...]

Emulate the docker-compose CLI for Docker Swarm

OPTIONS:"
  -e, --env list              Set environment variables
      --env-file stringArray  Specify an alternate environment file
  -f, --file stringArray      Compose configuration files
  -h, --help                  Display command usage help
  -H, --host string           Override the service host
  -P, --port number           Port to connect to host on (default:$DEFAULT_PORT)
  -p, --project-name string   Project(Stack) name
  -v, --verbose               Print verbose output

COMMANDS:
  config      Parse, resolve and render compose file in canonical format
  down        Stop and remove containers
  exec        Execute a command in a running container.
  logs        Fetch the logs of a container
  ls          List stacks.
  ps          List the tasks in the stack.
  services    List the services in the stack.
  up          Create and start containers
EOF
}

function parse_command() {
	# Parse options
	ENV_FILES=()
	CONFIG_FILES=()
	while [[ $# -gt 0 ]]; do
        case "${1}" in
            -e|--env)           shift; ENV_VARS+=("$1"); ;;
            --env-file)         ENV_FILES+=("$1"); shift; ENV_FILES+=("$1"); ;;
            -f|--file)          shift; CONFIG_FILES+=("$1"); ;;
            -h|--help)          usage_command; exit 0; ;;
            -H|--host)          shift; HOST="${1}"; ;;
            -P|--port)          shift; PORT="${1}"; ;;
            -p|--project-name)  shift; STACK="${1}"; ;;
            -v|--verbose)       VERBOSE=1; ;;
            *)                  COMMAND="${1}"; shift; break ;;
        esac
        shift
	done
	# Capture remaining arguments
    ARGV=( "$@" )
    # Handle default arguments
    CONFIG_FILES=(${CONFIG_FILES[@]:-$DEFAULT_CONFIG_FILES})
	# display debug output when VERBOSE is set
    [ -n "$VERBOSE" ] && echo "ENV_VARS=$ENV_VARS";
    [ -n "$VERBOSE" ] && echo "ENV_FILES=${ENV_FILES[@]}";
    [ -n "$VERBOSE" ] && echo "CONFIG_FILES=${CONFIG_FILES[@]}";
    [ -n "$VERBOSE" ] && echo "HOST=$HOST";
    [ -n "$VERBOSE" ] && echo "PORT=$PORT";
    [ -n "$VERBOSE" ] && echo "STACK=$STACK";
    [ -n "$VERBOSE" ] && echo "VERBOSE=$VERBOSE";
    [ -n "$VERBOSE" ] && echo "COMMAND=$COMMAND"
}

function usage_config() {
cat <<EOF

Usage: $DOCKERCMD [OPTIONS] config [CONFIG_OPTIONS] [EXEC_ARGS...]

Compile and display the config

OPTIONS:
  -h, --help                  Display command usage help
  -H, --host string           Override the service host
  -P, --port number           Port to connect to host on (default:$DEFAULT_PORT)
  -p, --project-name string   Project(Stack) name
  -v, --verbose               Print verbose output

CONFIG_OPTIONS
  -h, --help              Display config usage help
  -C, --no-compose-config Don't preprocess with docker-compose config
  -S, --no-stack-config   Don't process with docker-stack config
EOF
}

function parse_config() {

	# Parse options
	END_OF_OPT=
	POSITIONAL=()
	while [[ $# -gt 0 ]]; do
	case "${END_OF_OPT}${1}" in
		-h|--help)              usage_exec; exit 0 ;;
        -C|--no-compose-config) NO_COMPOSE_CONFIG=1; 
                                [ -n "$VERBOSE" ] && echo "NO_COMPOSE_CONFIG=$NO_COMPOSE_CONFIG"
                                ;;
        -S|--no-stack-config)   NO_STACK_CONFIG=1; 
                                [ -n "$VERBOSE" ] && echo "NO_STACK_CONFIG=$NO_STACK_CONFIG"
                                ;;
		--)                     END_OF_OPT=1; 
                                [ -n "$VERBOSE" ] && echo "END_OF_OPT=$END_OF_OPT"
                                ;;
		-*)                     invalid "$1" ;;
#		*)                      POSITIONAL+=("$1") ;;
	esac
	shift
	done
	# Capture remaining arguments
    ARGV=( "$@" )
}

function usage_exec() {
cat <<EOF

Usage: $DOCKERCMD [OPTIONS] exec [EXEC_OPTIONS] SERVICE [EXEC_ARGS...]

Execute a command in a running service

OPTIONS:
  -h, --help                  Display command usage help
  -H, --host string           Override the service host
  -P, --port number           Port to connect to host on (default:$DEFAULT_PORT)
  -p, --project-name string   Project(Stack) name
  -v, --verbose               Print verbose output

EXEC_OPTIONS
  -h, --help              Display command usage help
  -i, --interactive       Keep STDIN open even if not attached
  -t, --tty               Allocate a pseudo-TTY
  -u, --user string       Username or UID (format: "<name|uid>[:<group|gid>]")
  -w, --workdir string    Working directory inside the container
EOF
}

function parse_exec() {

	# Parse options
	END_OF_OPT=
	POSITIONAL=()
	while [[ $# -gt 0 ]]; do
	case "${END_OF_OPT}${1}" in
		-h|--help)          usage_exec; exit 0 ;;
        -i|--interactive)   INTERACTIVE=1; 
                            [ -n "$VERBOSE" ] && echo "INTERACTIVE=$INTERACTIVE"
                            ;;
        -t|--tty)           TTY=1; 
                            [ -n "$VERBOSE" ] && echo "TTY=$TTY"
                            ;;
		-u|--user)          shift; USERNAME="$1"; 
                            [ -n "$VERBOSE" ] && echo "USERNAME=$USERNAME";
                            ;;
        -w|--workdir)       shift; WORKDIR="$1"; 
                            [ -n "$VERBOSE" ] && echo "WORKDIR=$WORKDIR";
                            ;;
		--)                 END_OF_OPT=1; 
                            [ -n "$VERBOSE" ] && echo "END_OF_OPT=$END_OF_OPT"
                            ;;
		-*)                 invalid "$1" ;;
#		*)                  POSITIONAL+=("$1") ;;
        *)                  SERVICE="${1}"; shift; 
                            [ -n "$VERBOSE" ] && echo "SERVICE=$SERVICE"
                            break ;;
	esac
	shift
	done
	# Capture remaining arguments
    ARGV=( "$@" )
}

function usage_logs() {
cat <<EOF

Usage: $DOCKERCMD [OPTIONS] logs [LOGS_OPTIONS] SERVICE [LOGS_ARGS...]

Fetch the logs of a container

OPTIONS:
  -h, --help                  Display command usage help
  -H, --host string           Override the service host
  -P, --port number           Port to connect to host on (default:$DEFAULT_PORT)
  -p, --project-name string   Project(Stack) name
  -v, --verbose               Print verbose output

LOGS_OPTIONS
  -h, --help              Display command usage help
      --details           Show extra details provided to logs
  -f, --follow            Follow log output
  -n, --tail string       Number of lines to show from the end of the logs (default "all")
  -t, --timestamps        Show timestamps
EOF
}

function parse_logs() {

	# Parse options
	END_OF_OPT=
	POSITIONAL=()
	while [[ $# -gt 0 ]]; do
	case "${END_OF_OPT}${1}" in
		-h|--help)          usage_logs; exit 0 ;;
           --details)       DETAILS=1; 
                            [ -n "$VERBOSE" ] && echo "DETAILS=$DETAILS"
                            ;;
        -f|--follow)        FOLLOW=1; 
                            [ -n "$VERBOSE" ] && echo "FOLLOW=$FOLLOW"
                            ;;
		-n|--tail)          shift; TAIL="$1"; 
                            [ -n "$VERBOSE" ] && echo "TAIL=$TAIL";
                            ;;
        -t|--timestamps)    TIMESTAMPS=1;
                            [ -n "$VERBOSE" ] && echo "TIMESTAMPS=$TIMESTAMPS";
                            ;;
		--)                 END_OF_OPT=1; 
                            [ -n "$VERBOSE" ] && echo "END_OF_OPT=$END_OF_OPT"
                            ;;
		-*)                 invalid "$1" ;;
#		*)                  POSITIONAL+=("$1") ;;
        *)                  SERVICE="${1}"; shift; 
                            [ -n "$VERBOSE" ] && echo "SERVICE=$SERVICE"
                            break ;;
	esac
	shift
	done
	# Capture remaining arguments
    ARGV=( "$@" )
}

function lookup_node_and_container() {
	# Lookup the NODE and CONTAINER
    STACK_SERVICE_CMD="docker service ls -f name=$STACK --format '{{.Name}}' | grep $SERVICE | head -n1"
    [ -n "$VERBOSE" ] && echo "STACK_SERVICE_CMD=$STACK_SERVICE_CMD"
    STACK_SERVICE=$(eval "$STACK_SERVICE_CMD")
    [ -n "$VERBOSE" ] && echo "STACK_SERVICE=$STACK_SERVICE"
    NODE_CMD="docker service ps $STACK_SERVICE --format '{{.Node}}' | head -n1"
    [ -n "$VERBOSE" ] && echo "NODE_CMD=$NODE_CMD"
    NODE=$(eval "$NODE_CMD")
    [ -n "$VERBOSE" ] && echo "NODE=$NODE"
    CONTAINER_CMD="docker -H ${HOST:-$NODE}:${PORT:-2375} ps -f name=$STACK_SERVICE -q | head -n1" 
    [ -n "$VERBOSE" ] && echo "CONTAINER_CMD=$CONTAINER_CMD"
    CONTAINER=$(eval "$CONTAINER_CMD")
    [ -n "$VERBOSE" ] && echo "CONTAINER=$CONTAINER"
}


# Display usage when called without arguments
[ $# -lt 1 ] && usage_command && exit 0

# Preprocess to deal with long_opt=value type parameters
preprocess "$@"

# Apply pre-processed options
set -- "${ARGV[@]}"

# Parse main command
parse_command "$@"

# Apply remaining arguments
set -- "${ARGV[@]}"

# Restore the positional arguments
#set -- "${POSITIONAL[@]}"


# Application logic
# -----------------

if [ -z "$COMMAND" ]; then 
    missing "COMMAND"
fi

case "$COMMAND" in
    ls)                 exec docker stack $COMMAND "$@" ;;
    ps|services)        if [ -z "$STACK" ]; then
                            missing "STACK"
                        fi
                        exec docker stack $COMMAND $STACK "$@" ;;
    config)             parse_config "$@"
                        # Apply remaining arguments
                        set -- "${ARGV[@]}"
                        # FIXME: the following should be factored out into a function
                        #        so that it's also usable by deploy
                        if [ -z "$NO_COMPOSE_CONFIG" ]; then
                            COMPOSE_CONFIG_FILES=( $(prefix_array '-f' "${CONFIG_FILES[@]}") )
                            STACK_CONFIG_FILES=( '-c' '-' )
                            CONFIG_COMPOSE_CMD=( docker compose "${COMPOSE_CONFIG_FILES[@]}" config --no-consistency --no-normalize )
                            [ -n "$VERBOSE" ] && echo "CONFIG_COMPOSE_CMD=${CONFIG_COMPOSE_CMD[@]}"
                        else
                            STACK_CONFIG_FILES=( $(prefix_array '-c' "${CONFIG_FILES[@]}") )
                        fi
                        if [ -z "$NO_STACK_CONFIG" ]; then
                            CONFIG_STACK_CMD=( docker stack config "${STACK_CONFIG_FILES[@]}" "$@" )
                        fi
                        [ -n "$VERBOSE" ] && echo "CONFIG_STACK_CMD=${CONFIG_STACK_CMD[@]}"
                        if [ -n "$NO_COMPOSE_CONFIG" ] && [ -n "$NO_STACK_CONFIG" ]; then
                            echo "ERROR: -C and -S can't both be specified at the same time"
                            usage_config
                            exit 1
                        elif [ -z "$NO_COMPOSE_CONFIG" ] && [ -z "$NO_STACK_CONFIG" ]; then
                            CONFIG_CMD="${CONFIG_COMPOSE_CMD[@]} | ${UNQUOTE_NUMBERS_CMD[@]} | exec ${CONFIG_STACK_CMD[@]}"
                            [ -n "$VERBOSE" ] && echo "CONFIG_CMD=${CONFIG_CMD[@]}"
                            # Next line needs to be as follows otherwise we have problems with sed and the pipe |
                            ${CONFIG_COMPOSE_CMD[@]} | "${UNQUOTE_NUMBERS_CMD[@]}" | exec ${CONFIG_STACK_CMD[@]}
                        else
                            CONFIG_CMD="exec ${CONFIG_COMPOSE_CMD[@]} ${CONFIG_STACK_CMD[@]}"
                            [ -n "$VERBOSE" ] && echo "CONFIG_CMD=${CONFIG_CMD[@]}"
                            $CONFIG_CMD
                        fi
                        ;;
    deploy|up)          if [ -z "$STACK" ]; then
                            missing "STACK"
                        fi
                        # FIXME: check wether to use docker-compose or docker compose
                        #docker compose -f FILES config --no-consistency | exec docker stack deploy -c - $STACK "$@" 
                        $CONFIG_COMPOSE_CMD | $UNQUOTE_NUMBERS_CMD | exec docker stack deploy -c - $STACK "$@" 
                        ;;
    rm|down)            if [ -z "$STACK" ]; then
                            missing "STACK"
                        fi
                        exec docker stack rm $STACK "$@" ;;
    exec)               parse_exec "$@" 
                        # Apply remaining arguments
                        set -- "${ARGV[@]}"
						lookup_node_and_container
                        EXEC_OPTIONS="${INTERACTIVE:+ -i}${TTY:+ -t}${USERNAME:+ -u $USERNAME}${WORKDIR:+ -w $WORKDIR}"
                        [ -n "$VERBOSE" ] && echo "EXEC_OPTIONS=$EXEC_OPTIONS"
                        EXEC_ARGS="${@:-$DEFAULT_EXEC_ARGS}"
                        [ -n "$VERBOSE" ] && echo "EXEC_ARGS=$EXEC_ARGS"
                        EXEC_CMD="docker -H ${HOST:-$NODE}:${PORT:-$DEFAULT_PORT} exec${EXEC_OPTIONS} $CONTAINER $EXEC_ARGS"
                        [ -n "$VERBOSE" ] && echo "EXEC_CMD=$EXEC_CMD"
                        exec $EXEC_CMD
                        ;;
    logs)               parse_logs "$@" 
                        # Apply remaining arguments
                        set -- "${ARGV[@]}"
						lookup_node_and_container
                        LOGS_OPTIONS="${DETAILS:+ --details}${FOLLOW:+ -f}${TAIL:+ -n $TAIL}${TIMESTAMPS:+ -t}"
                        [ -n "$VERBOSE" ] && echo "LOGS_OPTIONS=$LOGS_OPTIONS"
                        LOGS_ARGS="${@:-$DEFAULT_LOGS_ARGS}"
                        [ -n "$VERBOSE" ] && echo "LOGS_ARGS=$LOGS_ARGS"
                        LOGS_CMD="docker -H ${HOST:-$NODE}:${PORT:-$DEFAULT_PORT} logs${LOGS_OPTIONS} $CONTAINER $LOGS_ARGS"
                        [ -n "$VERBOSE" ] && echo "EXEC_CMD=$LOGS_CMD"
                        exec $LOGS_CMD
                        ;;
    *)                  invalid "$COMMAND" ;;
esac

echo "ERROR: Should never see this."
exit 1
