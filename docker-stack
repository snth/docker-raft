#!/bin/bash
set -e

# Defaults
DEFAULT_PORT=2375
DEFAULT_EXEC_ARGS=bash

# Functions
function invalid() {
  echo "ERROR: Unrecognized argument: ${1}" >&2
  usage_command
  exit 1
}

function missing() {
    echo "ERROR: ${1} must be specified" >&2
    usage_command
    exit 1
}

function preprocess() {
	# Pre-process options to:
	# - expand -xyz into -x -y -z
	# - expand --longopt=arg into --longopt arg
	ARGV=()
	while [[ $# -gt 0 ]]; do
		arg="$1"; shift
		case "${END_OF_OPT}${arg}" in
			--) 	ARGV+=("$arg"); ;;
			--*=*)	ARGV+=("${arg%%=*}" "${arg#*=}") ;;
			--*) 	ARGV+=("$arg") ;;
			-*) 	for i in $(seq 2 ${#arg}); do 
						ARGV+=("-${arg:i-1:1}"); 
					done ;;
			*) 		ARGV+=("$arg") ;;
		esac
	done
}

# Report usage
function usage_command() {
    echo
    echo "Usage: $(basename "$0") [OPTIONS] COMMAND [ARG...]"
    echo
    echo "Emulate the docker-compose CLI for Docker Swarm"
    echo
    echo "OPTIONS:"
    echo "  -e, --env list              Set environment variables"
    echo "  -h, --help                  Display command usage help"
    echo "  -H, --host string           Override the service host"
    echo "  -P, --port number           Port to connect to host on (default:$DEFAULT_PORT)"
    echo "  -p, --project-name string   Project(Stack) name"
    echo "  -v, --verbose               Print verbose output"
    echo
    echo "COMMANDS:"
    echo "  ls          List stacks."
    echo "  exec        Execute a command in a running container."
    echo "  ps          List the tasks in the stack."
    echo "  services    List the services in the stack."
}

function parse_command() {
	# Parse options
	END_OF_OPT=
	POSITIONAL=()
	while [[ $# -gt 0 ]]; do
        case "${1}" in
            -e|--env)           shift; ENV_VARS+=("$1"); 
                                [ -n "$VERBOSE" ] && echo "ENV_VARS=$ENV_VARS";
                                ;;
            -h|--help)          usage_command; exit 0 ;;
            -H|--host)          shift; HOST="${1}"; 
                                [ -n "$VERBOSE" ] && echo "HOST=$HOST";
                                ;;
            -P|--port)          shift; PORT="${1}"; 
                                [ -n "$VERBOSE" ] && echo "PORT=$PORT";
                                ;;
            -p|--project-name)  shift; STACK="${1}"; 
                                [ -n "$VERBOSE" ] && echo "STACK=$STACK";
                                ;;
            -v|--verbose)       VERBOSE=1; 
                                [ -n "$VERBOSE" ] && echo "VERBOSE=$VERBOSE";
                                ;;
            *)                  COMMAND="${1}"; shift; 
                                [ -n "$VERBOSE" ] && echo "COMMAND=$COMMAND"
                                break ;;
        esac
        shift
	done
	# Capture remaining arguments
    ARGV=( "$@" )
}

function usage_exec() {
    echo
    echo "Usage: $(basename "$0") [OPTIONS] exec [EXEC_OPTIONS] SERVICE [EXEC_ARGS...]"
    echo
    echo "Execute a command in a running service"
    echo
    echo "OPTIONS:"
    echo "  -h, --help                  Display command usage help"
    echo "  -H, --host string           Override the service host"
    echo "  -P, --port number           Port to connect to host on (default:$DEFAULT_PORT)"
    echo "  -p, --project-name string   Project(Stack) name"
    echo "  -v, --verbose               Print verbose output"
    echo
    echo "EXEC_OPTIONS"
    echo "  -h, --help              Display command usage help"
    echo "  -i, --interactive       Keep STDIN open even if not attached"
    echo "  -t, --tty               Allocate a pseudo-TTY"
    echo "  -u, --user string       Username or UID (format: \"<name|uid>[:<group|gid>]\")"
    echo "  -w, --workdir string    Working directory inside the container"
}

function parse_exec() {

	# Parse options
	END_OF_OPT=
	POSITIONAL=()
	while [[ $# -gt 0 ]]; do
	case "${END_OF_OPT}${1}" in
		-h|--help)          usage_exec; exit 0 ;;
        -i|--interactive)   INTERACTIVE=1; 
                            [ -n "$VERBOSE" ] && echo "INTERACTIVE=$INTERACTIVE"
                            ;;
        -t|--tty)           TTY=1; 
                            [ -n "$VERBOSE" ] && echo "TTY=$TTY"
                            ;;
		-u|--user)          shift; USERNAME="$1"; 
                            [ -n "$VERBOSE" ] && echo "USERNAME=$USERNAME";
                            ;;
        -w|--workdir)       shift; WORKDIR="$1"; 
                            [ -n "$VERBOSE" ] && echo "WORKDIR=$WORKDIR";
                            ;;
		--)                 END_OF_OPT=1; 
                            [ -n "$VERBOSE" ] && echo "END_OF_OPT=$END_OF_OPT"
                            ;;
		-*)                 invalid "$1" ;;
#		*)                  POSITIONAL+=("$1") ;;
        *)                  SERVICE="${1}"; shift; 
                            [ -n "$VERBOSE" ] && echo "SERVICE=$SERVICE"
                            break ;;
	esac
	shift
	done
	# Capture remaining arguments
    ARGV=( "$@" )
}

function usage_logs() {
    echo
    echo "Usage: $(basename "$0") [OPTIONS] logs [LOGS_OPTIONS] SERVICE [LOGS_ARGS...]"
    echo
    echo "Fetch the logs of a container"
    echo
    echo "OPTIONS:"
    echo "  -h, --help                  Display command usage help"
    echo "  -H, --host string           Override the service host"
    echo "  -P, --port number           Port to connect to host on (default:$DEFAULT_PORT)"
    echo "  -p, --project-name string   Project(Stack) name"
    echo "  -v, --verbose               Print verbose output"
    echo
    echo "EXEC_OPTIONS"
    echo "  -h, --help              Display command usage help"
    echo "      --details           Show extra details provided to logs"
    echo "  -f, --follow            Follow log output"
    echo "  -n, --tail string       Number of lines to show from the end of the logs (default \"all\")"
    echo "  -t, --timestamps        Show timestamps"
}

function parse_logs() {

	# Parse options
	END_OF_OPT=
	POSITIONAL=()
	while [[ $# -gt 0 ]]; do
	case "${END_OF_OPT}${1}" in
		-h|--help)          usage_logs; exit 0 ;;
           --details)       DETAILS=1; 
                            [ -n "$VERBOSE" ] && echo "DETAILS=$DETAILS"
                            ;;
        -f|--follow)        FOLLOW=1; 
                            [ -n "$VERBOSE" ] && echo "FOLLOW=$FOLLOW"
                            ;;
		-n|--tail)          shift; TAIL="$1"; 
                            [ -n "$VERBOSE" ] && echo "TAIL=$TAIL";
                            ;;
        -t|--timestamps)    TIMESTAMPS=1;
                            [ -n "$VERBOSE" ] && echo "TIMESTAMPS=$TIMESTAMPS";
                            ;;
		--)                 END_OF_OPT=1; 
                            [ -n "$VERBOSE" ] && echo "END_OF_OPT=$END_OF_OPT"
                            ;;
		-*)                 invalid "$1" ;;
#		*)                  POSITIONAL+=("$1") ;;
        *)                  SERVICE="${1}"; shift; 
                            [ -n "$VERBOSE" ] && echo "SERVICE=$SERVICE"
                            break ;;
	esac
	shift
	done
	# Capture remaining arguments
    ARGV=( "$@" )
}



# Preprocess to deal with long_opt=value type parameters
preprocess "$@"

# Apply pre-processed options
set -- "${ARGV[@]}"

# Parse main command
parse_command "$@"

# Apply remaining arguments
set -- "${ARGV[@]}"

# Restore the positional arguments
#set -- "${POSITIONAL[@]}"

# Application logic
if [ -z "$COMMAND" ]; then 
    missing "COMMAND"
fi

case "$COMMAND" in
    ls)                 exec docker stack $COMMAND "$@" ;;
    ps|services)        if [ -z "$STACK" ]; then
                            missing "STACK"
                        fi
                        exec docker stack $COMMAND $STACK "$@" ;;
    exec)               parse_exec "$@" 
                        # Apply remaining arguments
                        set -- "${ARGV[@]}"
                        NODE_CMD="docker stack ps $STACK -f desired-state=running --format '{{ .Node }}' | head -n1"
                        [ -n "$VERBOSE" ] && echo "NODE_CMD=$NODE_CMD"
                        NODE=$(eval "$NODE_CMD")
                        [ -n "$VERBOSE" ] && echo "NODE=$NODE"
                        CONTAINER_CMD="docker -H ${HOST:-$NODE}:${PORT:-2375} ps -f name=$STACK_$SERVICE -q | head -n1" 
                        [ -n "$VERBOSE" ] && echo "CONTAINER_CMD=$CONTAINER_CMD"
                        CONTAINER=$(eval "$CONTAINER_CMD")
                        [ -n "$VERBOSE" ] && echo "CONTAINER=$CONTAINER"
                        EXEC_OPTIONS="${INTERACTIVE:+ -i}${TTY:+ -t}${USERNAME:+ -u $USERNAME}${WORKDIR:+ -w $WORKDIR}"
                        [ -n "$VERBOSE" ] && echo "EXEC_OPTIONS=$EXEC_OPTIONS"
                        EXEC_ARGS="${@:-$DEFAULT_EXEC_ARGS}"
                        [ -n "$VERBOSE" ] && echo "EXEC_ARGS=$EXEC_ARGS"
                        EXEC_CMD="docker -H ${HOST:-$NODE}:${PORT:-$DEFAULT_PORT} exec${EXEC_OPTIONS} $CONTAINER $EXEC_ARGS"
                        [ -n "$VERBOSE" ] && echo "EXEC_CMD=$EXEC_CMD"
                        exec $EXEC_CMD
                        ;;
    logs)               parse_logs "$@" 
                        # Apply remaining arguments
                        set -- "${ARGV[@]}"
                        NODE_CMD="docker stack ps $STACK -f desired-state=running --format '{{ .Node }}' | head -n1"
                        [ -n "$VERBOSE" ] && echo "NODE_CMD=$NODE_CMD"
                        NODE=$(eval "$NODE_CMD")
                        [ -n "$VERBOSE" ] && echo "NODE=$NODE"
                        CONTAINER_CMD="docker -H ${HOST:-$NODE}:${PORT:-2375} ps -f name=$STACK_$SERVICE -q | head -n1" 
                        [ -n "$VERBOSE" ] && echo "CONTAINER_CMD=$CONTAINER_CMD"
                        CONTAINER=$(eval "$CONTAINER_CMD")
                        [ -n "$VERBOSE" ] && echo "CONTAINER=$CONTAINER"
                        LOGS_OPTIONS="${DETAILS:+ --details}${FOLLOW:+ -f}${TAIL:+ -n $TAIL}${TIMESTAMPS:+ -t}"
                        [ -n "$VERBOSE" ] && echo "LOGS_OPTIONS=$LOGS_OPTIONS"
                        LOGS_ARGS="${@:-$DEFAULT_LOGS_ARGS}"
                        [ -n "$VERBOSE" ] && echo "LOGS_ARGS=$LOGS_ARGS"
                        LOGS_CMD="docker -H ${HOST:-$NODE}:${PORT:-$DEFAULT_PORT} logs${LOGS_OPTIONS} $CONTAINER $LOGS_ARGS"
                        [ -n "$VERBOSE" ] && echo "EXEC_CMD=$LOGS_CMD"
                        exec $LOGS_CMD
                        ;;
    *)                  invalid "$COMMAND" ;;
esac

echo "ERROR: Should never see this."
exit 1
